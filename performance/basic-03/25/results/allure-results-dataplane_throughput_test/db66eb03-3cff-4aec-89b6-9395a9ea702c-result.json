{"name": "test_tcp_upd_5g_band[setup_profiles0]", "status": "broken", "statusDetails": {"message": "socket.timeout", "trace": "self = <paramiko.Channel 0 (closed) -> <paramiko.Transport at 0x8053daf0 (cipher aes128-ctr, 128 bits) (active; 1 open channel(s))>>\nnbytes = 1024\n\n    def recv(self, nbytes):\n        \"\"\"\n        Receive data from the channel.  The return value is a string\n        representing the data received.  The maximum amount of data to be\n        received at once is specified by ``nbytes``.  If a string of\n        length zero is returned, the channel stream has closed.\n    \n        :param int nbytes: maximum number of bytes to read.\n        :return: received data, as a ``str``/``bytes``.\n    \n        :raises socket.timeout:\n            if no data is ready before the timeout set by `settimeout`.\n        \"\"\"\n        try:\n>           out = self.in_buffer.read(nbytes, self.timeout)\n\n/usr/local/lib/python3.8/site-packages/paramiko/channel.py:699: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.buffered_pipe.BufferedPipe object at 0x7f6b804fda90>\nnbytes = 1024, timeout = -0.0032167434692382812\n\n    def read(self, nbytes, timeout=None):\n        \"\"\"\n        Read data from the pipe.  The return value is a string representing\n        the data received.  The maximum amount of data to be received at once\n        is specified by ``nbytes``.  If a string of length zero is returned,\n        the pipe has been closed.\n    \n        The optional ``timeout`` argument can be a nonnegative float expressing\n        seconds, or ``None`` for no timeout.  If a float is given, a\n        `.PipeTimeout` will be raised if the timeout period value has elapsed\n        before any data arrives.\n    \n        :param int nbytes: maximum number of bytes to read\n        :param float timeout:\n            maximum seconds to wait (or ``None``, the default, to wait forever)\n        :return: the read data, as a ``str`` or ``bytes``\n    \n        :raises:\n            `.PipeTimeout` -- if a timeout was specified and no data was ready\n            before that timeout\n        \"\"\"\n        out = bytes()\n        self._lock.acquire()\n        try:\n            if len(self._buffer) == 0:\n                if self._closed:\n                    return out\n                # should we block?\n                if timeout == 0.0:\n                    raise PipeTimeout()\n                # loop here in case we get woken up but a different thread has\n                # grabbed everything in the buffer.\n                while (len(self._buffer) == 0) and not self._closed:\n                    then = time.time()\n                    self._cv.wait(timeout)\n                    if timeout is not None:\n                        timeout -= time.time() - then\n                        if timeout <= 0.0:\n>                           raise PipeTimeout()\nE                           paramiko.buffered_pipe.PipeTimeout\n\n/usr/local/lib/python3.8/site-packages/paramiko/buffered_pipe.py:164: PipeTimeout\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.e2e.basic.performance_tests.dataplane_throughput_test.test_bridge_mode.TestDataplaneThroughputBRIDGE object at 0x7f6b82f3ad60>\nget_vif_state = ['ssid_wpa2_2g', 'ssid_wpa2_5g']\nlf_tools = <lanforge.lf_tools.ChamberView object at 0x7f6b82fa4be0>\nlf_test = <lanforge.lf_tests.RunTest object at 0x7f6b82fa4070>\nstation_names_fiveg = ['sta1000'], create_lanforge_chamberview_dut = 'basic-03'\nget_configuration = {'access_point': [{'ip': '10.28.3.100', 'jumphost': True, 'jumphost_tty': '/dev/ttyAP3', 'mode': 'wifi5', ...}], 'cont...hy4'], '2.4G-Station-Name': 'sta00', '5G-Radio': ['1.1.wiphy5'], '5G-Station-Name': 'sta10', ...}, 'name': 'lanforge'}}\n\n    @pytest.mark.wpa2_personal\n    @pytest.mark.fiveg\n    def test_tcp_upd_5g_band(self, get_vif_state, lf_tools,\n                             lf_test, station_names_fiveg, create_lanforge_chamberview_dut, get_configuration):\n        \"\"\"Dataplane THroughput BRIDGE Mode\n           pytest -m \"dataplane_throughput_test and BRIDGE and wpa2_personal and fiveg\"\n        \"\"\"\n        profile_data = setup_params_general[\"ssid_modes\"][\"wpa2_personal\"][1]\n        ssid_name = profile_data[\"ssid_name\"]\n        security_key = profile_data[\"security_key\"]\n        security = \"wpa2\"\n        mode = \"BRIDGE\"\n        band = \"fiveg\"\n        vlan = 1\n        dut_name = create_lanforge_chamberview_dut\n        if ssid_name not in get_vif_state:\n            allure.attach(name=\"retest,vif state ssid not available:\", body=str(get_vif_state))\n            pytest.xfail(\"SSID NOT AVAILABLE IN VIF STATE\")\n        station = lf_test.Client_Connect(ssid=ssid_name, security=security,\n                                         passkey=security_key, mode=mode, band=band,\n                                         station_name=station_names_fiveg, vlan_id=vlan)\n    \n        if station:\n>           dp_obj = lf_test.dataplane(station_name=station_names_fiveg, mode=mode,\n                                       instance_name=\"TIP_DPT_DPT_WPA2_5G_BRIDGE\",\n                                       vlan_id=vlan, dut_name=dut_name)\n\ne2e/basic/performance_tests/dataplane_throughput_test/test_bridge_mode.py:96: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../libs/lanforge/lf_tests.py:344: in dataplane\n    self.dataplane_obj.run()\n../lanforge/lanforge-scripts/py-scripts/lf_dataplane_test.py:213: in run\n    self.create_and_run_test(self.load_old_cfg, self.test_name, self.instance_name,\n../lanforge/lanforge-scripts/py-json/cv_test_manager.py:367: in create_and_run_test\n    raise e  # Exception(\"Could not find Reports\")\n../lanforge/lanforge-scripts/py-json/cv_test_manager.py:362: in create_and_run_test\n    report.pull_reports(hostname=lf_host, username=lf_user, password=lf_password,\n../lanforge/lanforge-scripts/py-json/cv_test_reports.py:15: in pull_reports\n    scp.get(remote_path=report_location, local_path=report_dir, recursive=True)\n/usr/local/lib/python3.8/site-packages/scp.py:241: in get\n    self._recv_all()\n/usr/local/lib/python3.8/site-packages/scp.py:385: in _recv_all\n    msg = self.channel.recv(1024)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.Channel 0 (closed) -> <paramiko.Transport at 0x8053daf0 (cipher aes128-ctr, 128 bits) (active; 1 open channel(s))>>\nnbytes = 1024\n\n    def recv(self, nbytes):\n        \"\"\"\n        Receive data from the channel.  The return value is a string\n        representing the data received.  The maximum amount of data to be\n        received at once is specified by ``nbytes``.  If a string of\n        length zero is returned, the channel stream has closed.\n    \n        :param int nbytes: maximum number of bytes to read.\n        :return: received data, as a ``str``/``bytes``.\n    \n        :raises socket.timeout:\n            if no data is ready before the timeout set by `settimeout`.\n        \"\"\"\n        try:\n            out = self.in_buffer.read(nbytes, self.timeout)\n        except PipeTimeout:\n>           raise socket.timeout()\nE           socket.timeout\n\n/usr/local/lib/python3.8/site-packages/paramiko/channel.py:701: timeout"}, "description": "Dataplane THroughput BRIDGE Mode\n           pytest -m \"dataplane_throughput_test and BRIDGE and wpa2_personal and fiveg\"\n        ", "parameters": [{"name": "setup_profiles", "value": "{'mode': 'BRIDGE', 'ssid_modes': {'wpa2_personal': [{'ssid_name': 'ssid_wpa2_2g', 'appliedRadios': ['2G'], 'security_key': 'something', 'security': 'psk2'}, {'ssid_name': 'ssid_wpa2_5g', 'appliedRadios': ['5G'], 'security_key': 'something', 'security': 'psk2'}]}, 'rf': {}, 'radius': False}"}], "start": 1630065920985, "stop": 1630066426886, "uuid": "1a84e65e-7b31-49e4-b6e6-fa6ff8775162", "historyId": "d714e195ed25231ef7249716dc95df22", "testCaseId": "74e28f6fbe7812654486bc9be55a8f23", "fullName": "e2e.basic.performance_tests.dataplane_throughput_test.test_bridge_mode.TestDataplaneThroughputBRIDGE#test_tcp_upd_5g_band", "labels": [{"name": "feature", "value": "BRIDGE MODE Dataplane Throughput Test"}, {"name": "suite", "value": "performance"}, {"name": "tag", "value": "wpa2_personal"}, {"name": "tag", "value": "@pytest.mark.usefixtures('setup_profiles')"}, {"name": "tag", "value": "dataplane_throughput_test"}, {"name": "tag", "value": "fiveg"}, {"name": "tag", "value": "performance"}, {"name": "tag", "value": "bridge"}, {"name": "parentSuite", "value": "e2e.basic.performance_tests.dataplane_throughput_test"}, {"name": "subSuite", "value": "TestDataplaneThroughputBRIDGE"}, {"name": "host", "value": "perf-1174112102-5ff24"}, {"name": "thread", "value": "6-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "e2e.basic.performance_tests.dataplane_throughput_test.test_bridge_mode"}]}